### var声明及变量提升（Hoisting）机制

在函数作用域或全局变量中，通过var声明的变量，都会被当成在当前作用域顶部声明的变量，这就是我们常说的提升机制。

```javascript
function getValue(condition) {
	if (condition) {
		var value = 'blue';
		return value
	}else {
	// 此处可访问变量value，值为undefined.
		return null
	}
	// 此处可访问变量value，值为undefined.
}
```

在预编译阶段，Javascript引擎会将上面的代码修改成下面这样:

```javascript
function getValue(condition) {
	var value;
  if (condition) {
		value = 'blue';
		return value
	}else {
		return null
	}
}
```

变量value的声明被提升到函数作用域的顶部，而初始化操作依然留在原处执行，所以在别的地方可以访问，且值为undefined。



### 块级声明

块级声明用于声明在指定块的作用域之外无法访问的变量。块级作用域（亦称为词法作用域）存在于：

* 函数内部
* 块中（字符{和}之间的区域）

为了解决var的声明提升问题，所以es6中提供了块级声明：let和const。



### 块级声明的临时死区（Temporal Dead Zone TDZ）

因为let和const声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，即使是相对安全的typescript操作，也会触发引用错误。

```javascript
if (condition) {
  console.log(typeof value);  // 引用错误
  let value = 'blue';
}
```

Javascript引擎在扫描代码时发现的变量声明，要么将它们提升至作用域顶部（var声明），要么将声明放在TDZ中（let、const声明）。访问TDZ中的变量会触发运行时错误，只有执行过变量声明语句之后，变量才会从TDZ中移出，然后可以正常访问。



### 循环中的块级作用域

最常见的问题就是var声明使得循环中的函数比较难处理，因为var声明的变量在循环之外能访问。

```javascript
var funcs = []

for (var i=0;i<10;i++) {
  funcs.push(function(){console.log(i)});
}

funcs.forEach(function(func){func();}) // 输出10次的数字10
```

每次循环都共享着i变量。为了解决这个问题，之前是通过使用IIFE来每次给函数传入一个值的副本。

```javascript
var funcs = []

for (var i=0;i<10;i++) {
  funcs.push((function(value){
    return function() {
      console.log(value);
    }
  })(i));
}

funcs.forEach(function(func){func();}) // 0-9的输出
```

现在的话，可以通过let声明，在每次迭代循环时创建一个新的变量，并以之前迭代中同名变量的值将其初始化。意味着不用IIFE，也可以得到想要的效果了。

```javascript
var funcs = []

for (let i=0;i<10;i++) {
  funcs.push(function(){console.log(i)});
}

funcs.forEach(function(func){func();}) // 0-9的输出
```

并不适用于const声明，因为const声明后是不能修改值的。

> let声明在循环内部的行为是标准中专门定义的，它不一定与let的不提升特性相关。事实上，早期的let不包含上述功能，时候来加入的。



### 全局块作用域绑定

let和const与var的另外一个区别就是它们在全局作用域下的行为。当var被用于全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性。意味着var会<strong style="color:red">无意中覆盖</strong>一个已经存在的全局属性，就像这样:

```javascript
// 浏览器中
var RegExp = 'hello';
console.log(window.RegExp); // 'hello'

var ncz = 'Hi';
console.log(window.ncz); // 'Hi'
```

全局对象RegExp被定义为window上，但依然会被var声明覆盖。

如果你在全局作用域中使用let或const，会在全局作用域下创建一个新的绑定，当该绑定并不会添加为全局对象的属性。也就是用let或const并不能覆盖全局变量，只是遮住它。

```javascript
// 浏览器中
var RegExp = 'hello';
console.log(RegExp); // 'hello'
console.log(window.RegExp === RegExp); // false, 并没有修改window.RegExp，只是访问被遮盖住了。需要加上window前缀才能正常访问。
```



### 最佳实践

默认使用const，只在确实需要改变变量的值时使用let。这样就可以在某种程度上实现代码的不可变，从而防止某些错误的产生。

