JavaScript用“共享一切”的方法加载代码，这是该语言中最容易出错且容易让人感到困惑的地方。在ES6以前，在应用程序的每一个JavaScript中定义的一切都共享一个全局作用域。为了解决作用域的问题，于是引入了模块。

### 什么是模块

<strong>模块</strong>是自动运行在严格模式下并且没有办法退出运行的JavaScript代码。

与共享一切框架相反的是，在模块顶部创建的变量不会自动被添加到全局共享作用域，这个变量仅在模块的顶级作用域中存在，而且模块必须导出一些外部代码可以访问的元素，如变量或函数。模块也可以从其他模块导入绑定。

在模块的顶部，<strong>this</strong>的值是<strong>undefined</strong>；其次，模块不支持HTML风格的代码注释，这是从早期浏览器中残余下来的JavaScript特性。

脚本，也就是任何不是模块的JavaScript代码，则缺少上述特性。模块代表了JavaScript代码加载和求值的一个重要变化。模块真正的魔力所在是仅导出和导入你需要的绑定，而不是将所用东西都放到一个文件。



---



### 导出的基本语法

可以使用export关键字将一部分已发布的代码暴露给别的模块，在自己简单的用例中，可以将export放在任何变量、函数或类声明的前面，以便于将它们从模块中导出。

```javascript
// 导出数据
export const magicNum = 10;

// 导出函数
export function sum(num1, num2) {
  return num1 + num2;
};

// 导出类
export class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
}

// 这个函数是模块私有的
function subtract(num1, num2) {
  return num1 - num2;
}

// 定一个函数
function multiply(num1, num2) {
  return num1 * num2;
}
// 导出定义的函数
export multiply
```

注意，除非使用default关键字，否则不能用这个语法导出匿名函数或类（也就说导出的函数和类声明需要有一个名称）



---



### 导入的基本语法

从模块中导出的功能可以通过import关键字在另一个模块中访问，import语句的两个部分分别是：

* 要导入的标识符
* 标识符应该从哪个模块导入

```
import {identifier1, identifier2} from './examples1.js';
```

import后面的大括号表示从给定模块导入的绑定(binding)，关键字from表示从哪个模块导入给定的绑定，该模块由表示模块路径的字符串指定（被称为模块说明符）。浏览器使用的路径格式与`<script>` 元素的相同，所以必须带上文件扩展名。另一方面，Node.js遵循基于<strong>文件系统前缀区分本地文件和包的惯例</strong>。例如example是一个包，而`./example.js`是一个本地文件。

当从模块中导入一个绑定时，它就好像使用const定义的一样。结果是你无法定义另一个同名变量（包括导入另一个同名绑定），也无法在import语句前使用标识符或改变绑定的值。

#### 导入单个绑定

````javascript
import { sum } from './example.js';

sum = 1; // 抛出一个错误
````

> 为了最好的兼容多个浏览器和Node.js环境，一定要在字符串之前包含/、./或../来表示要导入的文件。

#### 导入多个绑定

如果想导入多个绑定，则可以明确地列出来

````javascript
import {sum, multiply, magicNum} from './example.js';
console.log(magicNum); // 10
````

从example模块导入3个绑定：sum、multiple和magicNum，之后使用它们，就像它们在本地定义的一样。

#### 导入整个模块

特殊情况下，可以导入整个模块作为一个单一的对象。然后所有的导出都可以作为对象的属性使用。

```javascript
import * as example from './exmaple.js';
console.log(example.magicNum); // 10
```

这种导入格式被称作命名空间导入(namesapce import)。因为example.js文件中不存在example对象，故而它作为example.js中所有导出成员的命名空间对象而被创建。

请记住，不管在import语句中把一个模块写了多少次，该模块只会执行一次。<strong>导入模块的代码执行后，实例化过的模块被保存在内存中</strong>，只要另一个import语句引用它就可以重复使用它。

```javascript
import {sum} from './example.js';
import {multiply} from './example.js';
```

尽管这个模块中有多次import，但是example.js将只执行一次。如果同一程序中的其它模块也要从example.js中导入绑定，那么这么模块与此代码将使用相同的模块实例。

> 模块语法的限制：export和import的一个重要限制是，它们必须在其他语句和函数外使用。模块语法存在的一个重要原因是要让JavaScript引擎静态地确定哪些可以导出。因此只能在模块顶部使用import。

#### 导入绑定的一个微妙怪异之处

ES6的import语句为变量、函数和类创建的是只读绑定，而不是像正常变量一样简单的引用原始绑定。标识符只有在被导出的模块中可以修改，即便是导入绑定的模块也无法更改绑定的值。

```javascript
export var name = 'joey';
export function setName(newName){
  name = newName;
};
```

当导入这两个绑定后，setName()函数可以修改name的值。

```javascript
import {name, setName} from './example.js';
console.log(name); // joey
setName('nicholas');
console.log(name); // nicholas

name = 'joey'; // 抛出错误
```

此处name的更改会自动在导入的name绑定上体现出来，因为name是导出的name标识符的本地名称。



---



### 导入和导出时重命名

可以使用as关键字来指定函数在模块外应该被称为什么名称。

```javascript
function sum(n1, n2) {
	return n1 + n2;
}

export {sum as add}
```

函数sum()是本地名称，add()是导出时使用的名称。所以，当另一个模块要导入这个函数时，必须使用add这个名称。

```javascript
import {add} from './example.js'; 
```

如果模块想使用的不同的名称来导入函数，也可以使用as关键字。

```javascript
import {add as sum} from './example.js';
console.log(typeof add); // undefined
console.log(sum(1,2)); // 3
```

这段代码导入add()函数时使用了一个导入名称来重命名sum()函数（当前上下文中的本地名称）。导入时改变函数的本地名称意味着即使模块导入了add()函数，在当前模块中也没有add()标识符。



---



### 模块的默认值

模块的默认值指的是通过default关键字指定的单个变量、函数或类，只能为每个模块设置一个默认的导出，导出时多次使用default关键字是一个错误的语法。

#### 导出默认值

```javascript
export default function(n1, n2) {
  return n1 + n2;
}
```

default关键字表示这是一个默认的导出，由于函数被模块所代表，因而它不需要一个名称。

也可以在export default之后添加默认导出值的标识符。

```javascript
function sum(n1, n2) {
  return n1 + n2;
}
export default sum;
```

为导出默认值指定标识符的第三种方法是使用重命名语法

```javascript
function sum(n1, n2) {
  return n1 + n2;
}
export {sum as default};
```

在重命名导出时标识符default具有特殊含义，用来指示模块的默认值。由于default是JavaScript中的默认关键字，因此不能将其用于变量、函数或类的名称；但是可以将其用作属性名称。所以使用default来重命名模块是为了尽可能与非默认导出的定义一致。

#### 导入默认值

可以使用以下语法从一个模块导入一个默认值

```javascript
import sum from './example.js';

console.log(sum(1, 2)); // 3
```

本地名称sum用于表示模块导出的任何默认函数，这种语法是最纯净的，ES6的创建者希望它能够成为Web上主流的模块导入形式，并且可以使用已有的对象。

对于导出默认值和一个或多个非默认绑定的模块，可以用一条语句导入所有导出的绑定。

```javascript
export let color = 'red';
export default function(n1, n2) {
  return n1 + n2;
}
```

```javascript
import sum, {color} from './example.js'

console.log(sum(1,2)); // 3
console.log(color); // red
```

用逗号将默认的本地名称与大括号包裹的非默认值分隔开，请记住，在import语句中，默认值必须排在非默认值之前。

```javascript
import {default as sum, color} from './example';
```

或者使用重命名的方式，默认导出export值被重命名为sum，并且还导入了color。上述两个import示例其实是一样的效果。



----



### 重新导出一个绑定

最终，可能需要重新导出模块已经导入的内容

```javascript
import {sum} from './example.js';
export {sum}
```

可以简写为：

```javascript
export {sum} from './example.js';
```

或者用不同的命名导出

```javascript
export {sum as add} from './example.js';
```

如果想导出另一个模块的所有值，可以使用*模式

```javascript
export * from './example.js';
```

导出一切是指带出默认值以及所有命名导出值，这可能会影响你可以从模块导出的内容。



---



### 无绑定导入

有些模块可能不导出任何东西，相反，它可能只修改全局作用域中的对象。

```javascript
// 没有export和import的模块代码
Array.prototype.pushAll = function(items) {}
```

这段代码即可以用作模块，也可以用作脚本。

```javascript
import './example.js';

let colors = [1,2,3];
let items = [];
items.pushAll(colors);
```

> 无绑定导入最有可能被应用于创建Polyfill和Shim。



---



### 加载模块

ES6没有尝试为所有JavaScript环境创建一套统一的标准，它只规定语法，并将加载机制抽象到一个未定义的内部方法`HostResolveImportedModule`中。Web浏览器和Node.js开发者可以通过对各自环境的认知来决定如何实现这个方法。

#### 在Web浏览器中使用模块

#####  在`<script>`中使用模块

`<script>`元素的默认行为是将JavaScript文件作为脚本加载，而非作为模块加载。讲type属性设置为“module”可以让浏览器讲所有内联代码或包含在src指定文件中的代码按照模块而非脚本的方式加载。

```javascript
<!--加载一个JS模块文件-->
<script type="module" src="module.js"></script>

<!--内联的方式引入一个JS模块文件-->
<script type="module">
	import {sum} from './exmaple.js';
	console.log(sum(1,2));
</script>
```

> 当浏览器无法识别type值时，会忽略\<script\>元素，因此不支持的浏览器提供良好的向后兼容性。

##### Web浏览器中模块加载顺序

`<script type="module">`执行时自动应用<strong>defer</strong>属性。

加载脚本文件时，defer是可选属性；加载模块时，defer是必需属性。

一旦HTML解析器遇到具有src属性的`<script type="module">`，模块文件便开始下载，直到文档被完全解析模块才会执行。模块按照它们出现在HTML文件中的顺序执行，也就是说，无论模块中包含的是内联代码还是指定src属性，第一个模块总是在第二个之前执行。

看最初的示例，模块module.js保证在内联模块前执行。

每个模块都可以从一个或多个其它的模块导入，这会使问题复杂化。因此首先解析模块以识别所有导入语句；然后每个导入语句都触发一次获取过程（从网络或缓存），并且在所有导入资源都被加载和执行后才会执行当前模块。

上述示例完整的加载顺序如下：

1. 下载并解析module.js
2. 递归下载并解析module.js中导入的资源
3. 解析内联模块
4. 递归下载并解析内联模块中导入的资源

加载完成之后，只有当文件被完全解析后才会执行其他操作，文档解析完成后：

1. 递归执行module.js中导入的资源
2. 执行module.js
3. 递归执行内联模块中导入的资源
4. 执行内联模块

##### Web浏览器中的异步模块加载

使用`async`属性，但是async属性不会影响脚本/模块执行的顺序，下载完成后会立即执行，而不必等待包含的文档完成解析。

```javascript
<script type="module" async src="module1.js"></script>
<script type="module" async src="module2.js"></script>
```

无法判断哪个模块先执行，哪个先下载完成先执行。

##### 将模块作为Worker加载

为了支持加载模块，Worker构造函数添加了第二个参数，用type属性来表示加载方式，默认是script值。

```javascript
// 按照模块的方式加载module.js
let worker = new Worker('module.js', {type: 'module'});
```



#### 浏览器模块说明符解析

在上述示例中，模块说明符（module specifier）使用的都是相对路径，浏览器要求模块说明符具有以下几种格式之一。

* 以/开头的解析从根目录开始
* 以./开头的解析从当前目录开始
* 以../开头的解析从父目录开始
* URL格式。



### 小结

ES6语言中的模块是一种打包和封装功能的方式，模块的行为与脚本不同，模块不会将它的顶级变量、函数和类修改为全局作用域，而且this的值为undefined。
