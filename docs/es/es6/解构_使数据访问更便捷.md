解构是一种打破数据结构，将其拆分为更小部分过程。

### 为什么使用结构

先看看es6之前，从对象和数组中获取特定数据，并赋值是怎么实现的

```javascript
let options = {
	repeat: true,
  save: false
};
// 从对象中提取数据
let repeat = options.repeat,
    save = options.save;
```

提取的过程比较的简单，但是会需要写很多同质化的代码，如果还包含嵌套结构，必须深入挖掘数据结构才能找到所需要的数据。

解构主要是将数据结构打散的过程变得更加的简单，可以从打散后更小的部分中获取所需的信息。



### 对象解构

对象解构的语法形式是在一个赋值操作符左边放置一个对象字面量。

```javascript
let options = {
	repeat: true,
  save: false
};
let {repeat, save} = options;
console.log(repeat); // true
console.log(save); // false
```



####  对象解构赋值

```javascript
let node = {
	type: 'Identifier',
  name: 'foo'
},
    type = 'Literal',
    name = 5;

// 使用解构赋值为多个变量赋值
({type, name} = node)

console.log(type); //Identifier
console.log(name); // foo
```

一定要用一堆小括号包裹解构赋值语句，Javascript引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句的左侧，添加了小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程。

解构赋值表达式的值与表达式右侧（=号右侧）的值相等。所以type、name只是进行赋值操作，最终返回的值，还是右侧的node，如果在传参的时候进行解构赋值，传递的是右侧的值。

#### 默认值

使用解构赋值表达式时，如果指定的局部变量名称在对象中不存在，那么这个局部变量会被赋值为undefined。

```javascript
let node = {
	type: 'Identifier',
  name: 'foo'
};

let {type, name, value} = node;
console.log(value); // undefined
```

当指定的属性不存在时，可以随意定义一个默认值，在属性名称后面添加一个等号（=）和相对应的默认值即可：

```javascript
let {type, name, value=10} = node;
console.log(value); // 10
```

只有当node上没有改属性，或者该属性值为undefined时该值才生效。

#### 为非同名局部变量赋值

如果你希望使用不同命名的局部变量来存储对象属性的值，ES6提供了一个新的语法来实现。

```javascript
let node = {
	type: 'Identifier',
  name: 'foo'
};
let {type: localType, name: localName} = node;
console.log(localType); // Identifier
console.log(localName); // foo
```

`type: localType`语法的含义是读取名为type的属性，并将其值存储在变量localType中。

当使用非同名变量名赋值时，也可以添加默认值，只需要在变量名后面添加等号和默认值即可。

```javascript
let {type: localType, name: localName, value: localValue = 'bar'} = node;
console.log(localValue); // bar
```

#### 嵌套对象解构

```javascript
let node = {
  type: 'Identifier',
  loc: {
    start: {
      line: 1,
      column: 1
    },
    end: {
      line: 1,
      column: 4
    }
  }
};

let {loc: {start}} = node;
console.log(start.line); // 1
console.log(start.column); // 1
```

在这个示例中，我们在解构模式中使用了花括号，其含义为在找到node对象中的loc属性之后，应当深入一层继续查找start属性。

在上面的解构示例中，所有冒号前的标识符都代表在对象中的检索位置，其右侧为被赋值的变量名；如果冒号后面是花括号，则意味着要赋值的最终对象嵌套在对象内部更深的层级中。

深层嵌套依然可以使用非同名等操作;

```javascript
let {loc: {start: localStart}} = node;
console.log(localStart); // {line:1, column: 1}
```



---



### 数组解构

与对象解构相比，数组解构会简单很多，它使用的是数组字面量，且解构操作全部在数组内完成，而不像对象字面量语法一样使用对象的命名属性

```javascript
let colors = ['red', 'green', 'blue'];
let [firstColor, secondColor] = colors;

console.log(firstColor); // red
console.log(secondColor); // green

let [,,thirdColor] = colors;
console.log(thirdColor); // blue
```

在数组解构语法中，我们通过值在数组中的位置进行选取，且可以将其存储在任意变量中，未显示声明的元素都会被直接忽略。在这个过程中，数组不会发生任何变化。

如果想直接取数组中的第3个值，则不需要提供前两个元素的变量名称，无论数组中有多少个元素，都可以通过逗号占位符这种方法提取想要的元素。

#### 数组解构赋值

数组解构也可以用于赋值上下文，但不需要用小括号包裹表达式，因为用的不是花括号吧。

```javascript
let colors = ['red', 'green', 'blue'],
    firstColor = 'black',
    secondColor = 'yellow';

[firstColor, secondColor] = colors;
console.log(firstColor); // red
console.log(secondColor); // green
```

##### 交换两个变量的值

数组解构语法独特的用例：交换两个变量的值。以前进行值交换的话，需要用一个第三方的中间值来存储才行。

```javascript
let a = 1, b = 2, temp;
temp = a;
a = b;
b = temp;
console.log(a); // 2
console.log(b); // 1

// 使用数组解构方式进行赋值
[a, b] = [b, a]
console.log(a); // 2
console.log(b); // 1
```

代码执行时，先解构临时数组，将b和a的值复制到左侧数组的前两个位置，最终结果是变量互换了它们的值。

#### 默认值

```javascript
let color = ['red'];
let [firstColor, secondColor = 'green'] = color;
console.log(secondColor); // green
```

#### 嵌套数组解构

语法和嵌套对象解构类似，在原有的数组模式中插入一个数组模式，即可将解构过程深入到下一个层级。

```javascript
let colors = ['red', ['green', 'blue'], 'light'];

let [firstColor, [secondColor]] = colors;
console.log(firstColor); // red
console.log(secondColor); // green
```

#### 不定参数

在数组中，可以通过...语法将数组中的其余元素赋值给一个特定的变量。

```javascript
let colors = ['red', 'green', 'blue'];
let [firstColor, ...secondColors] = colors;

console.log(secondColors); // ['green', 'blue']
```

其余元素都被赋值给secondColors，所以secondColors含有两个元素。不定元素语法有助于从数组中提取特定元素并保证其余元素可用。

> 在被解构的数组中，不定元素必须为最后一个条目，最后面继续添加逗号会导致程序抛出语法错误。

##### 不定参数的使用

在设计JavaScript时，很明显漏掉了数组的复制功能，一般都会用concat方法来实现。

```javascript
//es5
var colors = ['red', 'green', 'blue'];
var clonedColors = colors.concat();

// es6
let colors = ['red', 'green', 'blue'];
let [...clonedColors] = colors;
```

clonedColors都得到了colors数组的副本。



---



### 混合结构

```javascript
let node = {
  type: 'Identifier',
  loc: {
    start: {
      line: 1,
      column: 1
    },
    end: {
      line: 1,
      column: 4
    }
  },
  range: [0, 3]
};

let {loc: {start}, range: [startIndex]} = node;

console.log(start); // {line:1, column:1}
console.log(startIndex); // 0
```

这段代码分别将node.loc.start和node.range[0]提取到变量start和startIndex中。



#### 解构参数

解构可以用在参数传递过程中。当定义一个接受大量可选参数的函数时，通常会定义一个可选对象，将额外的队形定义为这个参数的属性。

```javascript
// options的属性表示其它参数
function setCookie(name, value, options) {
  options = options || {};
	
  let secure = options.secure,
      path = options.path;
  ...
}
  
setCookie('type', 'js', {secure: true, path: 'xxx'});
```

如果可选参数太多的话，就会有比较多的冗余代码，使用解构可以简化为：

```javascript
function setCookie(name, value, {secure, path}) {
  // 设置的代码
}
```

如果调用函数的时候，不提供被解构的参数会导致程序抛出错误。因为无法从undefined上去解构。所以可以给解构参数也加个默认值

```javascript
function setCookie(name, value, {secure, path}={}) {
  // 设置的代码
}
```

#### 解构参数的默认值

```javascript
function setCookie(name, value, {secure=true, path='/'}) {
  // 设置的代码
}
```

当定义函数参数时，使用解构参数代替options对象，可以将你真正感兴趣的数据和别的参数列在一起，使其更可读。
